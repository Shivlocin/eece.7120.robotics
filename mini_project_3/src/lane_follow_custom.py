#!/usr/bin/env python

import rospy
import roslib
import sys
import cv2
import numpy as np
from sensor_msgs.msg import CompressedImage
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

class FunHouse:
    def __init__(self):

        # Topics which can be used to monitor the processing.
        self.w_out_pub = rospy.Publisher('/pub_edges/white'  , Image, queue_size=1)
        self.y_out_pub = rospy.Publisher('/pub_edges/yellow' , Image, queue_size=1)

        # Get the images from the topic. I'm using Johns robot because I sacrificed mine to his father, Hades.
        self.sub = rospy.Subscriber("jmouse/image_transformer_node/corrected_image/compressed",
                                           CompressedImage, self.sub_callback)

        # Need this to convert ROS image messages to a format usable by the OpenCV library.
        self.bridge = CvBridge()

        # Image received from the topic.
        self.topic_image = None

        # Images generated by custom white/yellow edge detection code

        self.w_img = None
        self.y_img = None

    def sub_callback(self, msg):
        # Got bgr8 from image_conversion in duckietown_utils
        self.topic_image = self.bridge.compressed_imgmsg_to_cv2(msg, "bgr8")
        self.lane_filter(self.topic_image)
        self.pub_to_topics()



    def pub_to_topics(self):
        self.w_out_pub.publish(self.bridge.cv2_to_imgmsg(self.w_img, "bgr8"))
        self.y_out_pub.publish(self.bridge.cv2_to_imgmsg(self.y_img, "bgr8"))


    # Everything below this and above main is cut/paste from homework 8
    def lane_filter(self, image):
        # The incoming image is BGR format, convert it to HSV
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

        # Filter for only white pixels. Experiment with values as needed
        white_filter = cv2.inRange(hsv, (0, 0, 0), (180, 35, 255))

        # Filter for only yellow pixels. Experiment with values as needed
        yellow_filter = cv2.inRange(hsv, (20, 65, 178), (32, 255, 255))

        # Create a kernel to dilate the image.
        # Experiment with the numbers in parentheses (optional)
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))

        # Dilate both the white and yellow images.
        # No need to experiment here.
        white_dilate = cv2.dilate(white_filter, kernel)
        yellow_dilate = cv2.dilate(yellow_filter, kernel)

        # Perform edge detection on the original image.
        # Experiment with the first two numbers. Aperture size experimentation optional
        edges = cv2.Canny(image, 0, 300, apertureSize=3)


        # Use the edges to refine the lines in both white and yellow images
        # No need to experiment here
        white_edges = cv2.bitwise_and(white_dilate, edges)
        yellow_edges = cv2.bitwise_and(yellow_dilate, edges)

        self.w_img = self.get_lines(image, white_edges)
        self.y_img = self.get_lines(image, yellow_edges)

    # Taken directly from the homeworks
    def get_lines(self, original_image, filtered_image):
        # do our hough transform on the white image
        # resolution: 1 pixel radius, 1 degree rotational
        r_res = 1
        theta_res = np.pi / 180
        # threshold: number of intersections to define a line
        thresh = 9  # Default of 1
        # min_length: minimum number of points to form a line
        min_length = 10  # Default 1
        # max_gap: maximum gap between two points to be considered a line
        max_gap = 5
        lines = cv2.HoughLinesP(filtered_image, r_res, theta_res, thresh, np.empty(1), min_length, max_gap)

        output = np.copy(original_image)
        if lines is not None:
            # grab the first line
            for i in range(len(lines)):
                print(lines[i])
                l = lines[i][0]
                cv2.line(output, (l[0], l[1]), (l[2], l[3]), (0, 0, 255), 3, cv2.LINE_AA)
        return output


if __name__ == "__main__":

    # Create the node
    rospy.init_node('lane_follow_custom', anonymous=False)

    # Instantiate a FunHouse class. This is where the magic happens.
    fun_class = FunHouse()

    # Spin it DJ
    rospy.spin()
